:NewDefs

class A()
class B() extends A()
//│ class A()
//│ class B() extends A

fun p(x) = true
//│ fun p: anything -> true

fun f(x) = if
  x is B and
    x is A then 1
    p(x) then 2
  x is A then 31
  x is B then 3
  else 4
//│ fun f: (B | Object & ~#B) -> (2 | 31 | 3 | 4)



// FIXME should warn about unreachable code (3 disappears)
:ducs:postprocess.result
fun f(x) = if
  x is A and
    x is B then 1
    p(x) then 2
  x is B then 3
  else 4
//│ Post-processed UCS term:
//│ case x*‡ of
//│   refined A*◊ ->
//│     case x*‡ of
//│       B*◊ -> 1
//│       _ ->
//│         let ucs$test$0*† = p(x,) : Bool
//│         case ucs$test$0*† of
//│           true*† -> 2
//│           _ -> 4
//│   _ -> 4
//│ fun f: Object -> (1 | 2 | 4)


class X()
class Y()
//│ class X()
//│ class Y()

// FIXME should warn about unreachable code (1 disappears)
:ducs:postprocess.result
fun f(x) = if
  x is X and
    x is Y then 1
    p(x) then 2
  x is Y then 3
  else 4
//│ Post-processed UCS term:
//│ case x*‡ of
//│   X*◊ ->
//│     let ucs$test$0*† = p(x,) : Bool
//│     case ucs$test$0*† of
//│       true*† -> 2
//│       _ -> 4
//│   Y*◊ -> 3
//│   _ -> 4
//│ fun f: Object -> (2 | 3 | 4)

let x = [1, 2]
//│ let x: [1, 2]
//│ x
//│   = [ 1, 2 ]

let x = [
  1,
  2
]
//│ let x: [1, 2]
//│ x
//│   = [ 1, 2 ]

fun sign(x) = if x
  < 0 then -1
  > 0 then 1
  else 0
//│ fun sign: Num -> (-1 | 0 | 1)

sign(42)
sign(0)
sign(-10)
//│ -1 | 0 | 1
//│ res
//│     = 1
//│ res
//│     = 0
//│ res
//│     = -1
